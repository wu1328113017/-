一、Java基础篇
1，为什么重写了equals还要重写hashcode？
equals()相等的两个对象，hashcode()一般是相等的，最好在重写equals()方法时，重写hashcode()方法； equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等。 反过来：hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。在object类中，hashcode()方法是本地方法，返回的是对象的引用（地址值），而object类中的equals()方法比较的也是两个对象的引用（地址值），如果equals()相等，说明两个对象地址值也相等，当然hashcode()也就相等了。

2，说以下map的分类和常见的情况
map的分类有以下几种
	hashMap: 无序，允许存放为null的key和value，不允许存放重复的key，使用的是key的hashcode值来识别重复的，非同步
	treeMap：有序，根据保存的key来进行排序，默认是按升序排序，也可以指定排序的容器，不允许key的值为null，非同步的
	hashTable：不允许存放为null的key和value，不允许存放重复的key，是线程同步的，所以执行效率较慢
	linkedHashMap：以记录的插入顺序排序，key和value均允许为空，非同步的
3、Object若不重写hashCode()的话，hashCode()是如何计算出来的?
	Object的hashCode是本地方法，是用c++或c语言写的，返回的是对象的内存地址
4、==比较的是什么？
	对于对象引用类型，==比较的是内存地址，对于基本数据类型，==比较的是它的值

5、若对一个类不重写，它的equals()方法是如何比较的？
	如果没有对equals()方法进行重写，比较的是他们的内存地址，如果对equals()方法进行了重写，诸如String,Integer类的equals()方法比较的是他们的值
6、Java8新特性
				1，集合的foreach迭代新添了集合引用名.foreach加拉姆表达式的迭代方法，举个例子，迭代一个List集合，假如List集合的名字为list，那么新foreach迭代方式为list.foreach(a->System.out.println(a));其中a可以随便输入
	2.新添加了Lamdba表达式，lambda表达式是可以让方法做为一个参数（存放在方法参数括号内的参数),还简介化了代码，
7、lambda表达式的优缺点
	优点，简化了代码，非常容易并行计算，可能代表未来的编程趋势，
	缺点，难以维护，不容易调试，因为是Java8新特性，其他开发人员没有接触过一时间难以看懂
8、一个十进制的数在内存中是怎么存的？*

9、为啥有时会出现4.0-3.6 = 0.40000001这种现象？
	简单来说，2进制的小数无法精确的表达10进制的小数，计算机在计算10进制的小数时要先转换为2进制进行计算，在这个过程中可能出现了误差
10、Java支持的数据类型有哪些？什么是自动拆装箱？
	Java支持的数据类型有byte,char,short,int,long,float,double,boolean,在Java中对每个基本类型都进行了包装，这些包装类都放在java.lang这个包里面，八个包装类中除了char和int的包装类为Character和Integer外其他的基本类型的包装类名字除了包装类开头第一个英文大写外都一样，拆箱是指将包装类类型转换为基本数据类型，装箱则反过来，是指将基本数据类型转换为包装类类型，而自动拆装箱是在一些特定的情况下由程序自动的将他们进行一个转换，比如集合类只能存放对象，而当存入基本数据类型时不报错是因为在将基本数据类型放进去的时候自动转换成了包装类类型。当一个方法返回值为int类型，而return 后面接的是Integer类型，这时候自动的将Integer类型转换成了int类型，这就是自动拆箱
	
11、什么是值传递？什么是引用传递？
值传递是指将基本数据类型变量做为参数传递进去，方法接受的是copy该变量的另一个变量，所以在内存中会存在两个一样的变量，而改变方法体内的copy变量不会影响到原变量，引用传递是将对象的引用做为参数传递到方法体内，对象的引用指向该对象的内存地址，所以方法接受的是该引用的对象的内存地址，所以在方法体中对引用操作会直接影响到实际对象

12、Array和ArrayList的区别，适用于什么场景？
Array是数组，在声明Array的时候必须指明它的长度或初始化元素值，ArrayList的本质就是Array，不过ArrayList不用在声明的时候指明长度，每次给ArrayList添加元素时都会增长数组的长度的原来的百分之50，这样方便不断的改变数组长度来实现无限制容器大小来添加元素，所以也可以称ArrayList为可扩容Array，Array适用于在知道被存放元素个数和无须再次添加或删除的情况，ArrayList适用于未知数组长度的情况下

13、你了解大o符号吗？(big-o notation)么？你能给出不同数据结构的例子么？
大o符号用来描述一个数据结构在算法规模或者性能坏的情况下能有多好

14、String是最基本的类型吗?
不是

15、int和Integer的区别是什么？
int是基本数据类型，Integer是类，是int的包装类型

16、String和StringBuffer的区别？
String是不可变的字符串，S听Buffer是可变的字符串

17、我们在web应用开发过程中经常遇到输出某种编码的字符，如ISO8859-1等，如何输出一个某种编码的字符串？
先定义一个字符串，使用String类中的getByte方法将字符串转换为字节，然后将需要输出的某种编码的表达式以字符串的形式和字符串转换后的字节放入new String()括号参数体内并输出就可以完成输出一个某种编码的字符串

18、&和&&的区别？
&和&&都是逻辑运算符，使用&或&&的时候只要作左右两边有一边为false则运算结果为false
&与&&不同的是&&会短路，&&会短路的意思是左右两边只要左边为false就会立马停止运算返回false，而&会继续运算下去
举个例子:if(str != null && !str.equals("")){},假如str为null，当运行到str != null 时便返回false停止运算，所以代码不会报错，而是不会进入这个if里面，假如把&&换成&，则会执行!str.equals("")这段代码，因为str为null，所以程序会报空指针异常

19、在Java中如何跳出多重嵌套循环？
在第一层循环的最前面写上一个ok:，然后在满足跳出多重嵌套循环时执行break ok;，便会跳出多重嵌套循环了，而这个ok:可以是任意的，但必须与break 后面的表达式一样，而这种跳出多重嵌套循环的方式就像是在外面用了一个别名代替一个循环，然后break 这个别名;意思就是停止这个别名所代表的循环

20、你能比较一下Java和JavaScript吗？
Java是强类型语言，JavaScript是弱类型语言
Java是编写执行在后台服务端程序，JavaScript用来在页面进行数据渲染，前后端交互和动画效果的脚本语言
Java是标准的面向对象语言，任何程序都得设计面向对象
Java是原sun公司推出的一款语言，前身是oak语言，JavaScript是Netscape公司推出的一款语言，前身是liveScript语言
Java是先编译再解释，JavaScript无需编译由浏览器直接解释
两者之间的代码风格不一样

21、你能简述一下正则表达式及其用途吗？
在程序的编写中会对一些复杂字符串的进行一个规则上校验，而正则表达式就是用来描述这些规则。
用途:比如邮箱的校验，手机号码的校验等等很多，总之是用来做校验的，正则表达式写的好，一个复杂的字符串校验规则往往只需一段精彩绝伦的正则表达式完成

22、Java中如何支持正则表达式操作的？
Java中的String类提供了许多支持正则表达式操作的方法，包括:matches(),relpaceAll(),relpaceFrist,spit();
java也提供了一个Pattern类表示正则表达式对象。

23、请你说一说Java和PHP的区别？

番外:
24、continue,break,return,exit的作用和区别是什么？
continue的作用是结束当前循环直接进入下一次循环
break是结束当前循环并且不再循环，用在switch中的作用是结束switch语句的执行
return是直接返回方法指定的返回类型并结束方法
exit是退出程序
四者的区别就在于他们的作用范围不一样

二、关键字篇
1、介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？
因为静态方法是在类的对象初始化前就加载了的，所以修饰静态方法锁住的是类锁
而成员方法是类的对象初始化后才加载了的，所以修饰成员方法锁住的是对象锁

2、介绍一下volatile
被volatile修饰的对象的修改对其他线程是可见的，每次使用它都会去主存中重新读取，禁止指令重排

3、锁有了解吗？说一下Syncronized和lock
锁就是防止多个线程同时使用同一个方法而造成的数据错误的问题，被锁加持的方法或代码块只有在当前持有该方法或代码块的锁的线程执行完毕才会释放锁让别的线程调用，Syncronized和lock都是锁，但Syncronized是关键字，lock是对象，被Syncronized修饰的方法，线程调用到了此方法获得的是对象锁，也就是说其他线程调用的同一个对象的该方法时会等待之前获得对象锁的线程释放锁才会执行该方法，被Syncronized修饰的代码块会在Syncronized(obj)括号内的obj对象为对象锁，意思是使用了同一个obj对象的线程，会等待之前调用了该方法的线程执行完成才执行，lock是使用方法来进行锁的开启与关闭，与锁无关，锁住的是方法，而解锁的方法只能是调用该方法的线程执行完成

4、讲一讲Java里面的final关键字的用法
final意为最终的意思，被final修饰的对象不可以被修改
被final修饰的类不能被继承，其类方法均默认被final修饰
被final修饰的方法不能被重写
被final修饰的变量只能赋值一次

番外
5、介绍一下native
native修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言实现的文件中

三、面向对象
1、wait方法的底层原理
当线程执行到对象的wait方法是会释放所持有的对象锁
wait会将当前线程放入wait set，等待被唤醒，并放弃lock对象上的所有同步声明
1.将当前线程封装成objectWaiter对象node；
2.通过ObjectMonitor::AddWaiter方法将node添加到_WaitSet列表中
3.通过ObjectMonitor::exit方法释放当前的ObjectMonitor对象，这样其他竞争线程可以获取该ObjectMonitor对象
4.最终底层的park方法会挂起线程

2、Java有哪些特性？举一个多态的例子
抽象，继承，多态是Java语言的三大特性
多态的例子:声明一个接口类，声明多个实现类实现该接口，引用该接口类而初始化不同的实现类对象实例这样的例子就是多态

3、String为什么不可变？
因为它是final关键字修饰的

4、类和对象的区别？
类的普通方法是在初始化该类的对象实例才会加载在内存中，所以类除了静态方法可以直接调用外其他的普通方法都不会可以调用
对象是类实例化后存在于内存中，可以调用该对象除private修饰的所有方法
类是对一类事物的抽象概括，对象是具体到这一类事物的某样东西

5、请列举你所知道的Object类的方法
equals(),hashCode(),wait(),notify(),notifyAll(),toString()

6、重载和重写的区别？相同参数不同返回值能重载吗？
重载：在一个类里面多个方法名相同，参数个数不同，返回值可相同也可不相同
重写：子类声明与父类一模一样的方法且参数个数一样类型一样，返回值一样，总而言之，子类继承父类重新定义父类的方法
判断方法是否可重载只在于参数个数是否不相等，与返回值，参数类型均无关，所以相同参数不同返回值不能重载

7、"static"关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？
"static"关键字是静态的意思，被static修饰的方法称之为静态方法，外部获取静态方法只需该静态方法所在的类的类名.静态方法名即可，static修饰的变量与方法一样，被"static"修饰的对象在类加载器将类加载到jvm中的时候变化创建，这跟对象的是否创建无关，被static修饰的变量的改变会作用于全局，声明周期随着程序的结束而结束。
Java中不可以覆盖一个private或者是static的方法

8、String能被继承吗？
不能，String类是被final关键字修饰了的，被final修饰的类不能被继承，所以String类不能被继承

9、StringBuffer和StringBuilder有什么区别，底层实现上呢？
StringBuffer是同步的，StringBuilder是非同步的
底层实现上，StringBuffer其实就是比StringBuilder多了一个Syncronized关键字修饰

10、类加载机制，双亲委派模型，好处是什么？

11、静态变量存在哪？
全局区

12、讲讲什么是泛型？
泛型多用于容器，事先约定好什么类型，往容器中存放数据时会进行检查，不是约定的类型放入时会报错。

13、解释extends和supper泛型限定符-上界不存下界不取
extends指定上界限，只能传入本类和子类，supper指定下界限，只能传入本类和父类
上界不存的意思是上界的list不能add只能get
下界不取的意思是下界的list不能get只能add

14、是否可以在static环境访问非static变量？
不可以，被static修饰的对象会在类加载时就分配内存空间，而非"static"修饰的对象是在创建类的对象时分配内存空间，所以在static环境访问非static变量时，非static变量还未分配内存空间，也就是还不存在

15、谈谈如何通过反射创建对象？
反射创建对象有三种方式
方式1：通过创建对象
	String str = new String();
	Class clazz = str.getClass;
方式2：通过所在路径
	Class  clazz = Class.forName("java.lang.String");
方式3：通过类名
	Class clazz = String.class;

16、Java支持多继承吗？
	不支持，支持多实现，就是一个类可以实现多个接口类
	
17、Comparable和Comparator接口是干什么的？列出它们的区别。
	Comparable和Comparator接口是实现集合排序的接口，只不过Comparable是集合内部方法定义实现的排序，Comparator是集合外部实现的排序
	
18、面向对象的特征有哪些方面？
	1.抽象:抽象就是忽略那些与主题无关的方面，以便充分的关注与目标有关的方面。
	2.继承:子类继承父类的方法和属性，扩展新的东西。
	3.封装:封装就是类的私有化，将属性和业务代码封闭起来不对外开放，外部访问必须通过对象调用，保证类的属性和数据不受外部干扰
	4.多态:引用父类创建不同的该类的子类对象，能有不同的状态展示，引用一个接口类创建该接口类不同的实现类对象，也能有不同的状态展示，重写和重载都属于多态性的一个表现，重写为运行时多态，重写为编译时多态。
	
19、final、finally、finalize的区别
final是Java关键字，被final修饰的对象不能被改变，包括被final修饰的类不能被继承，修饰的方法不能被重写，修饰的变量只能赋值一次
finally是Java语法的一个语句，通常使用在try{}catch{}后面，作用是不管try{}里面有没有捕获到异常都会执行finally里面的代码
finalize是有关垃圾收集器的一个方法，垃圾回收器准备回收时会先调用finalize()方法

20、重载和重写的区别，重载的方法是否可以改变返回值的类型？
重载：同一个类里面存在多个相同方法名，相同参数类型不同参数个数，相同参数个数不同参数类型的方法
重写：子类继承父类，重新定义父类的方法，方法名，返回值类型，参数个数与参数类型必须与要重写的父类的方法一致
重载只与参数个数和参数类型有关，与返回值无关，所以重载的方法可以改变也可以不改变返回值的类型

21、abstract class和interface的区别？
abstract class为抽象类，抽象类可以声明有代码实现的方法与抽象方法，抽象方法不需要有具体的实现代码，可以声明构造器，抽象类不可以被实例化，必须由子类继承抽象类重写实现父类的抽象方法，就类似于实现类实现接口类的方法一样，子类只能继承一个抽象类，抽象类可以没有抽象方法，但抽象方法所在的类一定是抽象类
interface为接口类，里面清一色的为没有具体代码实现的方法，每个方法默认为abstract方法，由实现类继承实现接口类里面的方法，实现类可实现多个接口类，实现类必须实现接口类的所有方法

22、Static Nested Class 和 Inner Class的不同
static Nested Class是嵌套类，Inner Class是内部类
static Nested Class是静态类，Inner Class是非静态类
外部获取Static Nested Class的对象实例只需要new Static Nested Class的所在类的类名.Static Nested Class的类名即可
Inner Class需要获取到外部类的对象实例，然后通过外部类的对象实例来获取到Inner Class的对象实例

23、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?
是引用传递，引用传递传递的是对象的内存地址，在方法体内对引用传递传递过来的参数的改变实际上是改变了这个对象的内存地址，所以如果对象做为参数传入到方法中，方法对其改变，此改变使得传递进来的对象发生了改变，所以是引用传递

24、Java中接口和c++的虚类的相同和不同？
c++的虚类就跟Java中的抽象类差不多
相同之处在于都不能被实例化
不同之处在于:
抽象类可以有构造器，而接口类不能有构造器
只能继承一个抽象类，而接口可以实现多个
抽象类中可以有实现方法，接口类中不能有实现方法
一个抽象类可以是public，private，protected，default，接口只有public
一个抽象类的方法可以是public，private，protected，default，接口中的方法只有public和default

25、JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？
异常由程序员来处理，一般是在可能会发生异常的代码用try语句块包围，在catch处理异常发生后的代码

throws用来写在方法名()后面，标明这个方法可能会抛出的各种"异常"
throw用来抛出异常，使用throw用来明确的抛出一个异常，如果不被try捕获并处理会停止程序的运行
try用来捕获一段可能会发生异常的代码
catch用来处理try捕获到异常之后的代码
finally包围的代码是不管try有没有捕获到异常都会执行

26、内部类可以引用他包含类的成员吗？有没有什么限制？
内部类可以引用他包含类的成员，包括私有成员，但静态内部类只能引用静态成员

27、两个对象的值相同(x.equals(y) == true),但却可以有不同的hashCode说法是否正确？
Object是所有类的基类，在Object中equals中该方法的定义是直接判断比较的对象是否==被比较的对象，而hashCode是一个本地方法，是计算对象的内存地址返回哈希码，所以只要不重写，equlas判断比较的对象是否==被比较的对象为true的话，那么这两个对象就是同一个对象，所以他们的哈希码也是一样的，如果重写的话，jdk也对重写hashCode做了一个规定，重写的equals返回为true，那么返回的hashCode也应该为true，所以两个对象的值相同，但却可以有不同的hashCode的说法是错误的，但如果说特意而为，比如重写equals永远返回为true，重写hashCode永远返回一个随机数，也就是两个对象的值相同，但却可以有不同的hashCode的说法是正确的，所以不好做判断，因为规范只是规范，并不是强制需要这么做

28、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？
两者都是Java面对对象的特性之一多态性的体现
重载是同一个类中，多个方法同名，不同参数类型或不同参数个数，返回值可有可无，重载是编译时多态
重写是子类继承父类，定义了一个方法名，参数类型与参数个数参数摆放未知和是否有返回值与父类的其中一个方法一模一样，重载是运行时多态
重载只与参数有关，与返回值无关，所以重载的方法不能根据返回类型进行区分

29、如何通过反射获取和设置对象私有字段的值？
通过反射获取到对象的class实例，然后通过class的getDeclaredField方法获取到Java.lang下面的Field的实例
调用这个实例的方法setAccessible，传入参数为ture，再调用这个实例的方法set，传入参数为需要设置私有字段的值的对象以及需要设置的值，是为设置对象私有字段的值，调用这个实例的方法get，传入参数为需要获取私有字段的对象，是为获取对象私有字段的值
示例：测试类
	public class Test{
		private int i;
		public static void main(String[] args){
			//通过反射获取对象的class，以随便的一种方式获取
			try{
				Test test = new Test();
				Class clazz = test.getClass();
				Field field = clazz.getDeclaredField("i");
				field.setAccessible(true);
				//设置值
				field.set(test,10);
				//获取值							
				System.out.println(field.get(test));
			}catch(Exception e){
				e.printlnStatck();
			}
		}
	}
	运行以上代码，输出为10
30、谈一下面向对象的“六原则一法则”。
六原则为：
	1.单一职责原则：一个类只做它该做的事情
	
	2.开闭原则：软件实体应当对外扩展开发，修改关闭
	
	3.依赖倒转原则：面向接口编程，简单来说就算写一个方法，方法的参数类型，返回值类型尽量用抽象类型而不是具体类型，因为抽象类型可以被它的任何一个子类型替代
	
	4.里氏替换原则：任何时候能用父类型的地方就能用子类型替换。里氏替换原则就算检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，则说明这个继承关系一定是错误的，需要对代码进行重构
	
	5.接口隔离原则：接口要小而专，即代码少，实现的功能比较专一，而不要大而全，即代码多，把全部的功能都写完了
	
	6.合成聚合复用原则：优先使用聚合或合成关系复用代码
	
	
一法则为：
	迪米特法则：迪米特法则又称为最少知识原则，即一个对象对另一个对象的了解要尽可能的少
	
四、集合
1、Map和ConcurrentHashMap的区别？
Map是接口，ConcurrentHashMap是线程安全的

五、线程
1、多线程中的i++是否安全？为什么？
不安全，每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须把共享变量从主内存中加载到自己的工作内存，等完成操作在保存到主内存中，如果一个线程完成操作还没保存到主内存中，另一个线程又对共享变量进行操作，那么读取到的数据就算脏数据了

2、如何线程安全的实现一个计数器？
实现计数器的方法加上Syncronized关键字修饰

3、线程，进程，然后线程有很大开销，怎么优化？
可以使用线程池




	
	




